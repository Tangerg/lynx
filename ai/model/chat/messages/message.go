package messages

import (
	"errors"
	"maps"

	"github.com/Tangerg/lynx/ai/content"
)

// Type represents the type of a message in a chat conversation.
type Type string

// Message types for chat applications.
// These constants define the four types of messages that can be used
// in a chat conversation with AI models.
const (
	// System represents a system message containing high-level instructions
	// for the conversation, such as behavior guidelines or response format requirements.
	System Type = "system"

	// User represents a message from an end-user or developer,
	// typically containing queries or prompts.
	User Type = "user"

	// Assistant represents a message generated by the AI assistant
	// in response to user input.
	Assistant Type = "assistant"

	// Tool represents a message containing function call results
	// or tool execution outcomes in a chat application.
	Tool Type = "tool"
)

// String returns the string representation of the message type.
// It implements the fmt.Stringer interface.
func (t Type) String() string {
	return string(t)
}

// IsSystem reports whether the message type is System.
func (t Type) IsSystem() bool {
	return t == System
}

// IsUser reports whether the message type is User.
func (t Type) IsUser() bool {
	return t == User
}

// IsAssistant reports whether the message type is Assistant.
func (t Type) IsAssistant() bool {
	return t == Assistant
}

// IsTool reports whether the message type is Tool.
func (t Type) IsTool() bool {
	return t == Tool
}

// Message represents a message that can be sent or received in a chat application.
// Messages can contain text content, media attachments, metadata, and have specific types.
type Message interface {
	content.Content
	// Type returns the message type.
	Type() Type
	isMessage()
}

var _ Message = (*message)(nil)

// message is the internal implementation of the Message interface.
// It provides a base implementation for message content and metadata.
type message struct {
	text     string         // The text content of the message
	metadata map[string]any // Additional metadata associated with the message
}

func (m *message) isMessage() {}

func (m *message) Text() string {
	return m.text
}

func (m *message) Metadata() map[string]any {
	return m.metadata
}

func (m *message) Type() Type {
	panic("implement me")
}

// newMessage creates a new base message with specified text content and metadata.
// This function is used internally by specific message constructors.
//
// Parameters:
//   - text: The text content of the message
//   - metadata: Optional metadata map for additional message information
//
// Returns:
//   - message: Base message instance with the provided content and metadata
//
// The function performs a defensive copy of the metadata map to prevent
// external modifications after message creation.
func newMessage(text string, metadata map[string]any) message {
	var md map[string]any
	if metadata != nil {
		md = maps.Clone(metadata)
	} else {
		md = make(map[string]any)
	}
	return message{
		text:     text,
		metadata: md,
	}
}

// MessageParams contains the parameters needed to create a new message.
// It supports various message components including text, media, tool calls, and tool returns.
type MessageParams struct {
	Type        Type             // The type of the message (System, User, Assistant, or Tool)
	Text        string           // The text content of the message
	Metadata    map[string]any   // metadata for additional message information
	Media       []*content.Media // Media attachments (images, documents, etc.)
	ToolCalls   []*ToolCall      // Tool function calls for assistant messages
	ToolReturns []*ToolReturn    // Tool execution results for tool messages
}

// NewMessage creates a new message based on the provided parameters.
// It acts as a factory function that delegates to specific message constructors
// based on the message type.
//
// Parameters:
//   - params: MessageParams containing all necessary information for message creation
//
// Returns:
//   - Message: The created message instance
//   - error: An error if the message type is not supported
func NewMessage(params MessageParams) (Message, error) {
	switch params.Type {
	case System:
		return NewSystemMessage(params), nil
	case Assistant:
		return NewAssistantMessage(params), nil
	case User:
		return NewUserMessage(params), nil
	case Tool:
		return NewToolMessage(params)
	default:
		return nil, errors.New("message type not supported")
	}
}
