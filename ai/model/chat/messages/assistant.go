package messages

import (
	"github.com/Tangerg/lynx/ai/commons/content"
)

// ToolCall represents a function call made by the AI assistant.
// It contains the necessary information to identify and execute a specific tool.
type ToolCall struct {
	ID        string `json:"id"`        // Unique identifier for the tool call
	Type      string `json:"type"`      // Type of the tool call (e.g., "function")
	Name      string `json:"name"`      // Name of the function to call
	Arguments string `json:"arguments"` // JSON string containing function arguments
}

var (
	_ Message              = (*AssistantMessage)(nil)
	_ content.MediaContent = (*AssistantMessage)(nil)
)

// AssistantMessage represents a message generated by the AI assistant as a response to the user.
// This role indicates messages that the AI has previously generated in the conversation.
// By including assistant messages in the series, you provide context to the AI about
// prior exchanges in the conversation. AssistantMessage can contain text content,
// media attachments, and tool calls.
type AssistantMessage struct {
	message
	toolCalls []*ToolCall      // Tool calls made by the assistant
	media     []*content.Media // Media attachments in the response
}

// HasMedia returns true if the message contains any media attachments.
func (a *AssistantMessage) HasMedia() bool {
	return len(a.media) > 0
}

// Media returns the media attachments of the message.
func (a *AssistantMessage) Media() []*content.Media {
	return a.media
}

// HasToolCalls returns true if the message contains any tool calls.
func (a *AssistantMessage) HasToolCalls() bool {
	return len(a.toolCalls) > 0
}

// ToolCalls returns the tool calls made by the assistant.
func (a *AssistantMessage) ToolCalls() []*ToolCall {
	return a.toolCalls
}

// NewAssistantMessage creates a new assistant message with the given text content,
//
// media attachments, and tool calls. Both media and toolCalls parameters can be nil
// or empty slices if not needed.
//
// Optionally accepts metadata as a map. If multiple metadata maps are provided,
// only the first one will be used.
func NewAssistantMessage(text string, media []*content.Media, toolCalls []*ToolCall, metadata ...map[string]any) *AssistantMessage {
	if media == nil {
		media = make([]*content.Media, 0)
	}
	if toolCalls == nil {
		toolCalls = make([]*ToolCall, 0)
	}
	return &AssistantMessage{
		message:   newmessage(Assistant, text, metadata...),
		media:     media,
		toolCalls: toolCalls,
	}
}
