package messages

import (
	"slices"

	"github.com/Tangerg/lynx/ai/commons/content"
)

// ToolCall represents a function call made by the AI assistant.
// It contains the necessary information to identify and execute a specific tool.
type ToolCall struct {
	ID        string `json:"id"`        // Unique identifier for the tool call
	Type      string `json:"type"`      // Type of the tool call (e.g., "function")
	Name      string `json:"name"`      // Name of the function to call
	Arguments string `json:"arguments"` // JSON string containing function arguments
}

var (
	_ Message              = (*AssistantMessage)(nil)
	_ content.MediaContent = (*AssistantMessage)(nil)
)

// AssistantMessage represents a message generated by the AI assistant as a response to the user.
// This role indicates messages that the AI has previously generated in the conversation.
// By including assistant messages in the series, you provide context to the AI about
// prior exchanges in the conversation. AssistantMessage can contain text content,
// media attachments, and tool calls.
type AssistantMessage struct {
	message
	toolCalls []*ToolCall      // Tool calls made by the assistant
	media     []*content.Media // Media attachments in the response
}

// HasMedia returns true if the message contains any media attachments.
func (a *AssistantMessage) HasMedia() bool {
	return len(a.media) > 0
}

// Media returns the media attachments of the message.
func (a *AssistantMessage) Media() []*content.Media {
	return a.media
}

// HasToolCalls returns true if the message contains any tool calls.
func (a *AssistantMessage) HasToolCalls() bool {
	return len(a.toolCalls) > 0
}

// ToolCalls returns the tool calls made by the assistant.
func (a *AssistantMessage) ToolCalls() []*ToolCall {
	return a.toolCalls
}

type AssistantMessageParam struct {
	Text      string
	Media     []*content.Media
	ToolCalls []*ToolCall
	Metadata  map[string]any
}

// NewAssistantMessage creates a new assistant message using Go generics to simulate function overloading.
// This allows creating assistant messages with different parameter types in a single function call.
//
// Supported parameter types:
//   - string: Sets the text content
//   - []*content.Media: Sets media attachments
//   - []*ToolCall: Sets tool calls
//   - map[string]any: Sets metadata
//   - AssistantMessageParam: Complete parameter struct with all fields
//
// The function uses type constraints and type switching to handle different input types,
// providing a convenient API that mimics function overloading found in other languages.
//
// Examples:
//
//	NewAssistantMessage("Hello world")                    // Text only
//	NewAssistantMessage(mediaSlice)                       // Media only
//	NewAssistantMessage(toolCallSlice)                    // Tool calls only
//	NewAssistantMessage(metadataMap)                      // Metadata only, This is very useful in scenarios where the tool needs to return directly
//	NewAssistantMessage(AssistantMessageParam{...})       // Full configuration
func NewAssistantMessage[T string | []*content.Media | []*ToolCall | map[string]any | AssistantMessageParam](param T) *AssistantMessage {
	var p AssistantMessageParam

	input := any(param)
	switch input.(type) {
	case string:
		p.Text = input.(string)
	case []*content.Media:
		p.Media = input.([]*content.Media)
	case []*ToolCall:
		p.ToolCalls = input.([]*ToolCall)
	case map[string]any:
		p.Metadata = input.(map[string]any)
	case AssistantMessageParam:
		p = input.(AssistantMessageParam)
	}

	if p.Media == nil {
		p.Media = make([]*content.Media, 0)
	}
	if p.ToolCalls == nil {
		p.ToolCalls = make([]*ToolCall, 0)
	}

	return &AssistantMessage{
		message:   newMessage(Assistant, p.Text, p.Metadata),
		media:     slices.Clone(p.Media),
		toolCalls: slices.Clone(p.ToolCalls),
	}
}
