package messages

import (
	"slices"

	"github.com/Tangerg/lynx/ai/content"
)

// ToolCall represents a function call made by the AI assistant.
// It contains the necessary information to identify and execute a specific tool function.
type ToolCall struct {
	ID        string `json:"id"`        // Unique identifier for this specific tool call
	Name      string `json:"name"`      // Name of the function to be invoked
	Arguments string `json:"arguments"` // JSON-encoded string containing the function arguments
}

var (
	_ Message              = (*AssistantMessage)(nil)
	_ content.MediaContent = (*AssistantMessage)(nil)
)

// AssistantMessage represents a message generated by the AI assistant in response to user input.
// This message type indicates content that the AI has previously generated in the conversation.
// By including assistant messages in the conversation history, you provide context to the AI about
// prior exchanges. AssistantMessage can contain text content, media attachments, and tool calls
// for function execution.
type AssistantMessage struct {
	message
	media     []*content.Media // Media attachments included in the assistant's response
	toolCalls []*ToolCall      // Function calls initiated by the assistant
}

func (a *AssistantMessage) Type() Type {
	return Assistant
}

func (a *AssistantMessage) HasMedia() bool {
	return len(a.media) > 0
}

func (a *AssistantMessage) Media() []*content.Media {
	return a.media
}

// HasToolCalls reports whether the message contains any tool calls.
func (a *AssistantMessage) HasToolCalls() bool {
	return len(a.toolCalls) > 0
}

// ToolCalls returns a slice of tool calls made by the assistant.
func (a *AssistantMessage) ToolCalls() []*ToolCall {
	return a.toolCalls
}

// NewAssistantMessage creates a new assistant message using Go generics for type-safe parameter handling.
// This function provides a flexible API that accepts different parameter types to construct
// assistant messages with various content combinations.
//
// Supported parameter types:
//   - string: Sets the text content of the message
//   - []*content.Media: Sets media attachments for the message
//   - []*ToolCall: Sets tool calls initiated by the assistant
//   - map[string]any: Sets metadata for the message
//   - MessageParams: Complete parameter struct with all configurable fields
//
// The function uses type constraints and type switching to handle different input types,
// providing a convenient API for creating assistant messages with minimal boilerplate.
//
// Examples:
//
//	NewAssistantMessage("Hello world")                    // Creates message with text only
//	NewAssistantMessage(mediaSlice)                       // Creates message with media attachments
//	NewAssistantMessage(toolCallSlice)                    // Creates message with tool calls
//	NewAssistantMessage(metadataMap)                      // Creates message with metadata only
//	NewAssistantMessage(MessageParams{...})               // Creates message with full configuration
//
// Note: The metadata-only variant is particularly useful when tools need to return
// structured data without accompanying text content.
func NewAssistantMessage[T string | []*content.Media | []*ToolCall | map[string]any | MessageParams](param T) *AssistantMessage {
	var p MessageParams

	switch typedParam := any(param).(type) {
	case string:
		p.Text = typedParam
	case []*content.Media:
		p.Media = typedParam
	case []*ToolCall:
		p.ToolCalls = typedParam
	case map[string]any:
		p.Metadata = typedParam
	case MessageParams:
		p = typedParam
	}

	if p.Media == nil {
		p.Media = make([]*content.Media, 0)
	}
	if p.ToolCalls == nil {
		p.ToolCalls = make([]*ToolCall, 0)
	}

	return &AssistantMessage{
		message:   newMessage(p.Text, p.Metadata),
		media:     slices.Clone(p.Media),
		toolCalls: slices.Clone(p.ToolCalls),
	}
}
