package chat

import (
	"errors"
	"fmt"
	"maps"
	"slices"
	"strings"

	"github.com/Tangerg/lynx/ai/media"
	pkgSlices "github.com/Tangerg/lynx/pkg/slices"
)

// MessageType represents the type of a message in a chat conversation.
type MessageType string

// Message types for chat applications.
// These constants define the four types of messages that can be used
// in a chat conversation with AI models.
const (
	// MessageTypeSystem represents a system message containing high-level instructions
	// for the conversation, such as behavior guidelines or response format requirements.
	MessageTypeSystem MessageType = "system"

	// MessageTypeUser represents a message from an end-user or developer,
	// typically containing queries or prompts.
	MessageTypeUser MessageType = "user"

	// MessageTypeAssistant represents a message generated by the AI assistant
	// in response to user input.
	MessageTypeAssistant MessageType = "assistant"

	// MessageTypeTool represents a message containing function call results
	// or tool execution outcomes in a chat application.
	MessageTypeTool MessageType = "tool"
)

// String returns the string representation of the message type.
// It implements the fmt.Stringer interface.
func (t MessageType) String() string {
	return string(t)
}

// IsSystem reports whether the message type is MessageTypeSystem.
func (t MessageType) IsSystem() bool {
	return t == MessageTypeSystem
}

// IsUser reports whether the message type is MessageTypeUser.
func (t MessageType) IsUser() bool {
	return t == MessageTypeUser
}

// IsAssistant reports whether the message type is MessageTypeAssistant.
func (t MessageType) IsAssistant() bool {
	return t == MessageTypeAssistant
}

// IsTool reports whether the message type is MessageTypeTool.
func (t MessageType) IsTool() bool {
	return t == MessageTypeTool
}

// Message represents a message that can be sent or received in a chat application.
// Messages can contain text content, media attachments, metadata, and have specific types.
type Message interface {
	// Type returns the message type.
	Type() MessageType
	isMessage()
}

// ToolCall represents a function call made by the AI assistant.
// It contains the necessary information to identify and call a specific tool function.
type ToolCall struct {
	ID        string `json:"id"`        // Unique identifier for this specific tool call
	Name      string `json:"name"`      // Name of the function to be invoked
	Arguments string `json:"arguments"` // JSON-encoded string containing the function arguments
}

// ToolReturn represents the response from a tool function execution.
// It contains the result data and identification information that corresponds
// to a specific tool call made by the assistant.
type ToolReturn struct {
	ID     string `json:"id"`     // Unique identifier that matches the original tool call ID
	Name   string `json:"name"`   // Name of the tool function that was executed
	Result string `json:"result"` // The actual response data returned from the tool execution
}

// MessageParams contains the parameters needed to create a new message.
// It supports various message components including text, media, tool calls, and tool returns.
type MessageParams struct {
	Type        MessageType    `json:"type"`         // The type of the message (MessageTypeSystem, MessageTypeUser, MessageTypeAssistant, or MessageTypeTool)
	Text        string         `json:"text"`         // The text content of the message
	Metadata    map[string]any `json:"metadata"`     // metadata for additional message information
	Media       []*media.Media `json:"media"`        // Media attachments (images, documents, etc.)
	ToolCalls   []*ToolCall    `json:"tool_calls"`   // Tool function calls for assistant messages
	ToolReturns []*ToolReturn  `json:"tool_returns"` // Tool execution results for tool messages
}

// NewMessage creates a new message based on the provided parameters.
// It acts as a factory function that delegates to specific message constructors
// based on the message type.
//
// Parameters:
//   - params: MessageParams containing all necessary information for message creation
//
// Returns:
//   - Message: The created message instance
//   - error: An error if the message type is not supported
func NewMessage(params MessageParams) (Message, error) {
	switch params.Type {
	case MessageTypeSystem:
		return NewSystemMessage(params), nil
	case MessageTypeAssistant:
		return NewAssistantMessage(params), nil
	case MessageTypeUser:
		return NewUserMessage(params), nil
	case MessageTypeTool:
		return NewToolMessage(params)
	default:
		return nil, fmt.Errorf("unsupported message type: %s", params.Type)
	}
}

// AssistantMessage represents a message generated by the AI assistant in response to user input.
// This message type indicates content that the AI has previously generated in the conversation.
// By including assistant messages in the conversation history, you provide context to the AI about
// prior exchanges. AssistantMessage can contain text content, media attachments, and tool calls
// for function execution.
type AssistantMessage struct {
	Text      string         `json:"text"`
	Media     []*media.Media `json:"media"`
	ToolCalls []*ToolCall    `json:"tool_calls"`
	Metadata  map[string]any `json:"metadata"`
}

func (a *AssistantMessage) isMessage() {}

func (a *AssistantMessage) Type() MessageType {
	return MessageTypeAssistant
}

func (a *AssistantMessage) HasMedia() bool {
	return len(a.Media) > 0
}

// HasToolCalls reports whether the message contains any tool calls.
func (a *AssistantMessage) HasToolCalls() bool {
	return len(a.ToolCalls) > 0
}

// NewAssistantMessage creates a new assistant message using Go generics for type-safe parameter handling.
// This function provides a flexible API that accepts different parameter types to construct
// assistant messages with various content combinations.
//
// Supported parameter types:
//   - string: Sets the text content of the message
//   - []*media.Media: Sets media attachments for the message
//   - []*ToolCall: Sets tool calls initiated by the assistant
//   - map[string]any: Sets metadata for the message
//   - MessageParams: Complete parameter struct with all configurable fields
//
// The function uses type constraints and type switching to handle different input types,
// providing a convenient API for creating assistant messages with minimal boilerplate.
//
// Examples:
//
//	NewAssistantMessage("Hello world")                    // Creates message with text only
//	NewAssistantMessage(mediaSlice)                       // Creates message with media attachments
//	NewAssistantMessage(toolCallSlice)                    // Creates message with tool calls
//	NewAssistantMessage(metadataMap)                      // Creates message with metadata only
//	NewAssistantMessage(MessageParams{...})               // Creates message with full configuration
//
// Note: The metadata-only variant is particularly useful when tools need to return
// structured data without accompanying text content.
func NewAssistantMessage[T string | []*media.Media | []*ToolCall | map[string]any | MessageParams](param T) *AssistantMessage {
	var messageParams MessageParams

	switch typedParam := any(param).(type) {
	case string:
		messageParams.Text = typedParam
	case []*media.Media:
		messageParams.Media = typedParam
	case []*ToolCall:
		messageParams.ToolCalls = typedParam
	case map[string]any:
		messageParams.Metadata = typedParam
	case MessageParams:
		messageParams = typedParam
	}

	if messageParams.Media == nil {
		messageParams.Media = make([]*media.Media, 0)
	}
	if messageParams.ToolCalls == nil {
		messageParams.ToolCalls = make([]*ToolCall, 0)
	}
	if messageParams.Metadata == nil {
		messageParams.Metadata = make(map[string]any)
	}

	return &AssistantMessage{
		Text:      messageParams.Text,
		Media:     messageParams.Media,
		ToolCalls: messageParams.ToolCalls,
		Metadata:  messageParams.Metadata,
	}
}

// SystemMessage represents a system message that provides high-level instructions
// and context for the AI conversation. System messages typically contain behavior
// guidelines, response format requirements, role definitions, or conversational rules.
//
// System messages are processed before user messages and help establish the AI's
// behavior and response style. For example, you might use a system message to
// instruct the AI to behave like a specific character, follow particular guidelines,
// or provide answers in a designated format.
type SystemMessage struct {
	Text     string         `json:"text"`
	Metadata map[string]any `json:"metadata"`
}

func (m *SystemMessage) isMessage() {}

func (m *SystemMessage) Type() MessageType {
	return MessageTypeSystem
}

// NewSystemMessage creates a new system message using Go generics for type-safe parameter handling.
// This function provides a flexible API that accepts different parameter types to construct
// system messages with varying content configurations.
//
// Supported parameter types:
//   - string: Sets the text content of the system message
//   - MessageParams: Complete parameter struct containing text content and metadata
//
// The function uses type constraints and type switching to handle different input types,
// providing a convenient API for creating system messages with minimal boilerplate code.
//
// Examples:
//
//	NewSystemMessage("You are a helpful assistant")      // Creates system message with text only
//	NewSystemMessage(MessageParams{                       // Creates system message with full configuration
//	    Text: "You are a helpful assistant",
//	    Metadata: map[string]any{"priority": "high"},
//	})
//
// Note: System messages are typically placed at the beginning of a conversation
// to establish the AI's behavior and context for subsequent interactions.
func NewSystemMessage[T string | MessageParams](param T) *SystemMessage {
	var messageParams MessageParams

	switch typedParam := any(param).(type) {
	case string:
		messageParams.Text = typedParam
	case MessageParams:
		messageParams = typedParam
	}
	if messageParams.Metadata == nil {
		messageParams.Metadata = make(map[string]any)
	}
	return &SystemMessage{
		Text:     messageParams.Text,
		Metadata: messageParams.Metadata,
	}
}

// UserMessage represents a message from an end-user or developer in the conversation.
// User messages typically contain questions, prompts, requests, or any input that
// requires a response from the AI assistant. UserMessage supports both text content
// and media attachments such as images, audio files, documents, or other multimedia content.
type UserMessage struct {
	Text     string         `json:"text"`
	Media    []*media.Media `json:"media"`
	Metadata map[string]any `json:"metadata"`
}

func (u *UserMessage) isMessage() {}

// Type returns the message type as User.
func (u *UserMessage) Type() MessageType {
	return MessageTypeUser
}

// HasMedia reports whether the message contains any media attachments.
func (u *UserMessage) HasMedia() bool {
	return len(u.Media) > 0
}

// NewUserMessage creates a new user message using Go generics for type-safe parameter handling.
// This function provides a flexible API that accepts different parameter types to construct
// user messages with various content combinations.
//
// Supported parameter types:
//   - string: Sets the text content of the user message
//   - []*media.Media: Sets media attachments for the message
//   - MessageParams: Complete parameter struct with text, media, and metadata fields
//
// The function uses type constraints and type switching to handle different input types,
// providing a convenient API for creating user messages with minimal boilerplate code.
//
// Examples:
//
//	NewUserMessage("Hello, how are you?")               // Creates message with text only
//	NewUserMessage(mediaSlice)                          // Creates message with media attachments only
//	NewUserMessage(MessageParams{                       // Creates message with full configuration
//	    Text: "What's in this image?",
//	    Media: mediaSlice,
//	    Metadata: map[string]any{"source": "mobile_app"},
//	})
//
// Note: User messages with media attachments are commonly used for multimodal AI interactions
// where the assistant needs to analyze images, process documents, or handle other media types.
func NewUserMessage[T string | []*media.Media | MessageParams](param T) *UserMessage {
	var messageParams MessageParams

	switch typedParam := any(param).(type) {
	case string:
		messageParams.Text = typedParam
	case []*media.Media:
		messageParams.Media = typedParam
	case MessageParams:
		messageParams = typedParam
	}

	if messageParams.Media == nil {
		messageParams.Media = make([]*media.Media, 0)
	}
	if messageParams.Metadata == nil {
		messageParams.Metadata = make(map[string]any)
	}
	return &UserMessage{
		Text:     messageParams.Text,
		Media:    messageParams.Media,
		Metadata: messageParams.Metadata,
	}
}

// ToolMessage represents a message containing the results from tool function executions.
// This message type is used to provide the outcomes of function/tool calls back to the
// AI assistant, enabling it to continue the conversation with access to the tool execution
// results. Tool messages typically contain multiple tool returns corresponding to previous
// tool calls made by the assistant.
type ToolMessage struct {
	ToolReturns []*ToolReturn  // Results from executed tool functions
	Metadata    map[string]any `json:"metadata"`
}

func (t *ToolMessage) isMessage() {}

// Type returns the message type as Tool.
func (t *ToolMessage) Type() MessageType {
	return MessageTypeTool
}

// NewToolMessage creates a new tool message using Go generics for type-safe parameter handling.
// This function provides a flexible API that accepts different parameter types to construct
// tool messages containing execution results from previously called functions.
//
// Supported parameter types:
//   - []*ToolReturn: Sets the tool execution results directly
//   - MessageParams: Complete parameter struct with tool returns and metadata fields
//
// The function uses type constraints and type switching to handle different input types,
// providing a convenient API for creating tool messages with minimal boilerplate code.
//
// Requirements:
//   - At least one tool return must be provided in the toolReturns parameter
//
// Note: Tool messages typically have empty text content since the actual response
// data is contained within the individual tool return results.
//
// Examples:
//
//	NewToolMessage(toolReturnSlice)                       // Creates message with tool returns only
//	NewToolMessage(MessageParams{                         // Creates message with full configuration
//	    ToolReturns: toolReturnSlice,
//	    Metadata: map[string]any{"execution_time": "2ms"},
//	})
//
// Returns:
//   - *ToolMessage: The created tool message containing the execution results
//   - error: Non-nil error if no tool returns are provided
func NewToolMessage[T []*ToolReturn | MessageParams](param T) (*ToolMessage, error) {
	var messageParams MessageParams

	switch typedParam := any(param).(type) {
	case []*ToolReturn:
		messageParams.ToolReturns = typedParam
	case MessageParams:
		messageParams = typedParam
	}

	if len(messageParams.ToolReturns) == 0 {
		return nil, errors.New("tool message must contain at least one tool return")
	}
	if messageParams.Metadata == nil {
		messageParams.Metadata = make(map[string]any)
	}
	return &ToolMessage{
		ToolReturns: messageParams.ToolReturns,
		Metadata:    messageParams.Metadata,
	}, nil
}

// hasMessageTypeAtLast reports whether the last message in a slice has the specified type.
//
// Parameters:
//   - messages: The slice of messages to check
//   - messageType: The expected message type
//
// Returns:
//   - bool: True if the last message has the specified type, false otherwise
//
// Note: Returns false for empty slices or when the last message is nil.
func hasMessageTypeAtLast(messages []Message, messageType MessageType) bool {
	return hasMessageTypeAt(messages, -1, messageType)
}

// hasMessageTypeAt reports whether the message at a specific index has the specified type.
// Supports both positive and negative indexing (-1 for last element, -2 for second-to-last, etc.).
//
// Parameters:
//   - messages: The slice of messages to check
//   - index: The index to check (supports negative indexing)
//   - messageType: The expected message type
//
// Returns:
//   - bool: True if the message at the specified index has the expected type, false otherwise
//
// Note: Returns false for out-of-bounds indices or nil messages.
func hasMessageTypeAt(messages []Message, index int, messageType MessageType) bool {
	messageAtIndex, exists := pkgSlices.At(messages, index)
	if !exists {
		return false
	}

	return messageAtIndex != nil && messageAtIndex.Type() == messageType
}

// FilterMessages creates a new slice containing only messages that satisfy the predicate function.
//
// Parameters:
//   - messages: The slice of messages to filter
//   - predicate: Function that returns true for messages to include in the result
//
// Returns:
//   - []Message: New slice containing only messages that match the predicate
//
// Note: Returns an empty slice if no messages are provided or no messages match the predicate.
// Panics if the predicate function is nil.
func FilterMessages(messages []Message, predicate func(message Message) bool) []Message {
	if predicate == nil {
		panic("FilterMessages: predicate function cannot be nil")
	}

	if len(messages) == 0 {
		return make([]Message, 0)
	}

	filteredMessages := make([]Message, 0, len(messages))
	for _, msg := range messages {
		if predicate(msg) {
			filteredMessages = append(filteredMessages, msg)
		}
	}
	return filteredMessages
}

// FilterMessagesByMessageTypes returns a new slice containing only messages that match any of the specified types.
// Nil messages are automatically excluded and the original message order is preserved.
//
// Parameters:
//   - messages: The slice of messages to filter
//   - types: Variable number of message types to include (System, User, Assistant, Tool)
//
// Returns:
//   - []Message: New slice containing only messages of the specified types
//
// Note: If no types are specified, returns the original slice unchanged.
//
// Example:
//
//	FilterMessagesByMessageTypes(msgs, User, Assistant) // Returns only user and assistant messages
func FilterMessagesByMessageTypes(messages []Message, types ...MessageType) []Message {
	if len(types) == 0 {
		return messages
	}

	return FilterMessages(messages, func(message Message) bool {
		return message != nil && slices.Contains(types, message.Type())
	})
}

// excludeNilMessages returns a new slice with all nil messages removed.
//
// Parameters:
//   - messages: The slice of messages to filter
//
// Returns:
//   - []Message: New slice with all nil messages removed
//
// Note: This function is useful for cleaning up message slices that may contain nil values.
func excludeNilMessages(messages []Message) []Message {
	return FilterMessages(messages, func(message Message) bool {
		return message != nil
	})
}

// MergeSystemMessages combines multiple SystemMessage instances into a single SystemMessage.
// Text content is concatenated with double newlines as separators, and metadata from all
// messages is merged with later messages overwriting earlier ones for duplicate keys.
//
// Parameters:
//   - messages: The slice of messages to filter and merge
//
// Returns:
//   - *SystemMessage: The merged system message, or nil if no system messages are found
func MergeSystemMessages(messages []Message) *SystemMessage {
	systemMessages := FilterMessagesByMessageTypes(messages, MessageTypeSystem)

	if len(systemMessages) == 0 {
		return nil
	}
	if len(systemMessages) == 1 {
		return systemMessages[0].(*SystemMessage)
	}

	textBuilder := strings.Builder{}
	mergedMetadata := make(map[string]any)

	for _, msg := range systemMessages {
		systemMessage := msg.(*SystemMessage)
		textBuilder.WriteString(systemMessage.Text)
		textBuilder.WriteString("\n\n")
		maps.Copy(mergedMetadata, systemMessage.Metadata)
	}

	return NewSystemMessage(
		MessageParams{
			Text:     strings.TrimSuffix(textBuilder.String(), "\n\n"),
			Metadata: mergedMetadata,
		})
}

// MergeUserMessages combines multiple UserMessage instances into a single UserMessage.
// Text content is concatenated with double newlines, media content is combined into a single slice,
// and metadata is merged with later messages overwriting earlier ones for duplicate keys.
//
// Parameters:
//   - messages: The slice of messages to filter and merge
//
// Returns:
//   - *UserMessage: The merged user message, or nil if no user messages are found
func MergeUserMessages(messages []Message) *UserMessage {
	userMessages := FilterMessagesByMessageTypes(messages, MessageTypeUser)

	if len(userMessages) == 0 {
		return nil
	}
	if len(userMessages) == 1 {
		return userMessages[0].(*UserMessage)
	}

	textBuilder := strings.Builder{}
	mergedMetadata := make(map[string]any)
	combinedMedia := make([]*media.Media, 0)

	for _, msg := range userMessages {
		userMessage := msg.(*UserMessage)
		textBuilder.WriteString(userMessage.Text)
		textBuilder.WriteString("\n\n")
		maps.Copy(mergedMetadata, userMessage.Metadata)
		combinedMedia = append(combinedMedia, userMessage.Media...)
	}

	return NewUserMessage(MessageParams{
		Text:     strings.TrimSuffix(textBuilder.String(), "\n\n"),
		Media:    combinedMedia,
		Metadata: mergedMetadata,
	})
}

// MergeToolMessages combines multiple ToolMessage instances into a single ToolMessage.
// All tool returns are combined into a single slice and metadata is merged with later
// messages overwriting earlier ones for duplicate keys.
//
// Parameters:
//   - messages: The slice of messages to filter and merge
//
// Returns:
//   - *ToolMessage: The merged tool message, or nil if no tool messages are found
//   - error: Non-nil if the merge operation fails
func MergeToolMessages(messages []Message) (*ToolMessage, error) {
	toolMessages := FilterMessagesByMessageTypes(messages, MessageTypeTool)

	if len(toolMessages) == 0 {
		return nil, nil
	}
	if len(toolMessages) == 1 {
		return toolMessages[0].(*ToolMessage), nil
	}

	mergedMetadata := make(map[string]any)
	combinedToolReturns := make([]*ToolReturn, 0)

	for _, msg := range toolMessages {
		toolMessage := msg.(*ToolMessage)
		maps.Copy(mergedMetadata, toolMessage.Metadata)
		combinedToolReturns = append(combinedToolReturns, toolMessage.ToolReturns...)
	}

	return NewToolMessage(MessageParams{
		ToolReturns: combinedToolReturns,
		Metadata:    mergedMetadata,
	})
}

// MergeMessages merges messages of the specified type using the appropriate merge function.
// Each message type has its own merging strategy to preserve type-specific data.
//
// Parameters:
//   - messages: The slice of messages to merge
//   - messageType: The message type to filter and merge (System, User, or Tool)
//
// Returns:
//   - Message: The merged message of the specified type, or nil if no messages of that type are found
//   - error: Non-nil for unsupported message types or merge failures
//
// Note: Assistant messages are not supported for merging as they typically represent individual
// AI responses that should remain separate to maintain conversation context.
func MergeMessages(messages []Message, messageType MessageType) (Message, error) {
	if messageType.IsSystem() {
		return MergeSystemMessages(messages), nil
	}

	if messageType.IsUser() {
		return MergeUserMessages(messages), nil
	}

	if messageType.IsTool() {
		return MergeToolMessages(messages)
	}

	return nil, fmt.Errorf("unsupported message type for merging: %s", messageType.String())
}

// adjacentSameTypeMerger handles the process of merging consecutive messages of the same type.
type adjacentSameTypeMerger struct {
	sourceMessages    []Message // Source messages to process
	mergedMessages    []Message // Resulting merged messages
	currentGroupStart int       // Start index of current group being processed
}

// merge processes all messages and returns the result with adjacent same-type messages merged.
func (merger *adjacentSameTypeMerger) merge() []Message {
	for currentIndex := 1; currentIndex <= len(merger.sourceMessages); currentIndex++ {
		if merger.isGroupEnd(currentIndex) {
			merger.processCurrentGroup(currentIndex)
			merger.currentGroupStart = currentIndex
		}
	}
	return merger.mergedMessages
}

// isGroupEnd determines if the current group of same-type messages has ended.
func (merger *adjacentSameTypeMerger) isGroupEnd(currentIndex int) bool {
	if currentIndex == len(merger.sourceMessages) {
		return true
	}
	return merger.sourceMessages[currentIndex].Type() != merger.sourceMessages[merger.currentGroupStart].Type()
}

// processCurrentGroup merges the current group of messages if possible.
func (merger *adjacentSameTypeMerger) processCurrentGroup(endIndex int) {
	messageGroup := merger.sourceMessages[merger.currentGroupStart:endIndex]

	if len(messageGroup) == 1 {
		merger.mergedMessages = append(merger.mergedMessages, messageGroup[0])
		return
	}

	mergedMessage, err := MergeMessages(messageGroup, messageGroup[0].Type())
	if err == nil {
		merger.mergedMessages = append(merger.mergedMessages, mergedMessage)
	} else {
		// If merging fails, keep original messages
		merger.mergedMessages = append(merger.mergedMessages, messageGroup...)
	}
}

// MergeAdjacentSameTypeMessages combines consecutive messages of the same type into single messages.
// Only adjacent messages with identical types are merged together, preserving the overall
// conversation structure while reducing redundancy.
//
// Parameters:
//   - messages: The slice of messages to process
//
// Returns:
//   - []Message: New slice with adjacent same-type messages merged
//
// Note: Non-adjacent messages or messages with different types remain separate.
// Nil messages are automatically filtered out before processing.
//
// Example:
//
//	Input:  [UserMsg, UserMsg, SystemMsg, UserMsg, ToolMsg, ToolMsg]
//	Output: [MergedUserMsg, SystemMsg, UserMsg, MergedToolMsg]
func MergeAdjacentSameTypeMessages(messages []Message) []Message {
	nonNilMessages := excludeNilMessages(messages)
	if len(nonNilMessages) <= 1 {
		return nonNilMessages
	}

	merger := &adjacentSameTypeMerger{
		sourceMessages: nonNilMessages,
		mergedMessages: make([]Message, 0, len(nonNilMessages)),
	}

	return merger.merge()
}

// lastIndexOfType finds the last occurrence of a message with the specified type.
//
// Parameters:
//   - messages: The slice of messages to search through
//   - messageType: The message type to search for
//
// Returns:
//   - int: The index of the last message with the specified type, or -1 if not found
//   - Message: The message at that index, or nil if not found
//
// Note: Automatically skips nil messages during the search.
func lastIndexOfType(messages []Message, messageType MessageType) (int, Message) {
	for index := len(messages) - 1; index >= 0; index-- {
		msg := messages[index]
		if msg != nil && msg.Type() == messageType {
			return index, msg
		}
	}
	return -1, nil
}

// augmentLastMessageOfType finds the last message of the specified type and applies
// a transformation function to it. The transformation occurs in-place within the original slice.
//
// Parameters:
//   - messages: The slice of messages to modify (modified in-place)
//   - messageType: The type of message to find and transform
//   - transformFunction: Function that takes the found message and returns a transformed version
//
// Note: If the transformation function returns nil, the original message remains unchanged.
// If no message of the specified type is found, no modification occurs.
func augmentLastMessageOfType(messages []Message, messageType MessageType, transformFunction func(message Message) Message) {
	if transformFunction == nil {
		return
	}

	lastIndex, lastMessage := lastIndexOfType(messages, messageType)
	if lastIndex == -1 {
		return
	}

	transformedMessage := transformFunction(lastMessage)
	if transformedMessage != nil {
		messages[lastIndex] = transformedMessage
	}
}

// augmentTextLastMessageOfType appends additional text to the last message of the specified type.
// The text is appended with double newlines as separators. Only supports UserMessage and
// SystemMessage types as they contain modifiable text content.
//
// Parameters:
//   - messages: The slice of messages to modify (modified in-place)
//   - messageType: The type of message to find and augment (User or System)
//   - additionalText: The text to append to the found message
//
// Note: If the message type doesn't support text augmentation, no modification occurs.
// For unsupported message types (Assistant, Tool), the function silently does nothing.
func augmentTextLastMessageOfType(messages []Message, messageType MessageType, additionalText string) {
	augmentLastMessageOfType(messages, messageType, func(currentMessage Message) Message {
		switch typedMessage := currentMessage.(type) {
		case *UserMessage:
			typedMessage.Text = typedMessage.Text + "\n\n" + additionalText
			return typedMessage
		case *SystemMessage:
			typedMessage.Text = typedMessage.Text + "\n\n" + additionalText
			return typedMessage
		default:
			return typedMessage // Return unchanged for unsupported types
		}
	})
}
